{
    "collab_server" : "",
    "contents" : "#' Fit a Random Rotation Forest.\n#'\n#' Fit a Random Rotation Forest using randomised trees with orthogonal or oblique splits as base learners.\n#' @param x Training data input matrix.\n#' @param y Training data response.\n#' @param K The number of variable subsets. The default is the value K that results in three features per subset.\n#' @param L The number of base classfiers.\n#' @param mtry Number of variables randomly sampled as candidates at each split.\n#' @param model Specifies the base learner model: 'rpart' for ordinary classification trees; 'rf' for\n#'    randomised trees; 'ridge', 'pls', 'log', 'svm' or 'rnd' for randomised trees using oblique splits with the corresponding model.\n#' @param ... Additional arguments specified to \\code{randomForest}, \\code{rpart} or \\code{obliqueRF}.\n#' @return A fitted model object of type 'RRotF', which is a list containing base learner fits and PCA loadings.\n#' @author Arnu Pretorius: \\email{arnupretorius@gmail.com}\n#' @references Rodriguez, J.J., Kuncheva, L.I., 2006. Rotation forest: A new classifier ensemble method. IEEE Trans. Pattern Anal. Mach. Intell. 28, 1619-1630. doi:10.1109/TPAMI.2006.211\n#' @seealso \\code{\\link{predict.RRotF}}\n#' @examples\n#' library(ElemStatLearn)\n#' library(caret)\n#' data(\"SAheart\")\n#' trainIndex <- createDataPartition(SAheart$chd, p=0.6, list=FALSE)\n#' train <- SAheart[trainIndex,]\n#' test <- SAheart[-trainIndex,]\n#' Xtrain <- train[,-10]\n#' ytrain <- train[,10]\n#' Xtest <- test[,-10]\n#' ytest <- test[,10]\n#' mod <- RRotF(Xtrain, ytrain, model=\"log\")\n#' preds <- predict(mod, Xtest)\n#' error <- mean(preds != ytest)\n#' error\n#' @export\n\nRRotF <- function (x, y, K = round(ncol(x)/3, 0), L = 10, mtry=floor(sqrt(ncol(x))), model=\"log\", ...){\n\n      require(randomForest)\n      require(rpart)\n      require(obliqueRF)\n      x <- data.frame(sapply(x, as.numeric))\n      y <- factor(as.numeric(y)-1)\n      while (ncol(x)%%K != 0) {\n            K <- K - 1\n      }\n      M <- round(ncol(x)/K)\n      predicted <- list()\n      fit <- numeric()\n      Ri <- list()\n      Ria <- list()\n      fit <- list()\n      predicted <- matrix(NA, nrow = nrow(x), ncol = L)\n      subsets <- list()\n      SelectedClass <- list()\n      IndependentsClassSubset <- list()\n      IndependentsClassSubsetBoot <- list()\n      pcdata <- list()\n      loadings <- list()\n      for (i in 1:L) {\n            Independents <- x[, sample(1:ncol(x), ncol(x))]\n            n <- 0\n            subsets[[i]] <- list()\n            SelectedClass[[i]] <- list()\n            IndependentsClassSubset[[i]] <- list()\n            IndependentsClassSubsetBoot[[i]] <- list()\n            pcdata[[i]] <- list()\n            loadings[[i]] <- list()\n            for (j in seq(1, K)) {\n                  n <- n + M\n                  subsets[[i]][[j]] <- data.frame(Independents[, (n -\n                                                                        (M - 1)):n], y)\n                  SelectedClass[[i]][[j]] <- as.integer(sample(levels(as.factor(y)),\n                                                               1))\n                  IndependentsClassSubset[[i]][[j]] <- subsets[[i]][[j]][subsets[[i]][[j]]$y ==\n                                                                               SelectedClass[[i]][[j]], ]\n                  IndependentsClassSubsetBoot[[i]][[j]] <- IndependentsClassSubset[[i]][[j]][sample(1:dim(IndependentsClassSubset[[i]][[j]])[1],\n                                                                                                    round(0.75 * nrow(IndependentsClassSubset[[i]][[j]])),\n                                                                                                    replace = TRUE), ]\n                  pcdata[[i]][[j]] <- princomp(IndependentsClassSubsetBoot[[i]][[j]][,\n                                                                                     !colnames(IndependentsClassSubsetBoot[[i]][[j]]) %in%\n                                                                                           \"y\"])\n                  loadings[[i]][[j]] <- pcdata[[i]][[j]]$loadings[,\n                                                                  ]\n                  colnames(loadings[[i]][[j]]) <- dimnames(loadings[[i]][[j]])[[1]]\n                  loadings[[i]][[j]] <- data.frame(dimnames(loadings[[i]][[j]])[[1]],\n                                                   loadings[[i]][[j]])\n                  colnames(loadings[[i]][[j]])[1] <- \"rowID\"\n            }\n            Ri[[i]] <- Reduce(function(x, y) merge(x, y, by = \"rowID\",\n                                                   all = TRUE), loadings[[i]])\n            Ri[[i]][is.na(Ri[[i]])] <- 0\n            Ria[[i]] <- Ri[[i]][order(match(Ri[[i]]$rowID, colnames(x))),\n                                order(match(colnames(Ri[[i]]), colnames(x)))]\n            rownames(Ria[[i]]) <- Ria[[i]]$rowID\n            Ria[[i]]$rowID <- NULL\n            finalx <- data.frame(as.matrix(x) %*% as.matrix(Ria[[i]]))\n            final <- data.frame(finalx, y)\n            if(model==\"rf\"){\n                  fit[[i]] <- randomForest(y ~ ., data = final, mtry=mtry, ntree=1,\n                                           ...)\n            } else if(model %in% c(\"ridge\", \"pls\", \"log\", \"svm\", \"rnd\")){\n                  capture.output(fit[[i]] <- obliqueRF(x = as.matrix(finalx), y=as.numeric(y), mtry=mtry, ntree=1,\n                                                       training_method=model, verbose = FALSE, ...))\n            } else {\n                  stop(\"Argument 'model' not a valid model type.\")\n            }\n      }\n      res <- list(models = fit, loadings = Ria, columnnames = colnames(x), mod=model)\n      class(res) <- \"RRotF\"\n      res\n}\n",
    "created" : 1471538821574.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4038383428",
    "id" : "26D89A51",
    "lastKnownWriteTime" : 1471542663,
    "last_content_update" : 1471542663380,
    "path" : "~/Google Drive/University/Masters/My Packages/RRotF/R/RRotF.R",
    "project_path" : "R/RRotF.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}